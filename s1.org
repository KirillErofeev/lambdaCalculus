* Семестровая 1
** Общие типы
Во всех заданиях определены следующие тип.
#+BEGIN_src haskell
newtype Symbol = Symbol { unSymbol :: String } deriving (Eq,Show,Read)
#+END_src
** Варианты
В скобках после заголовка - раздел в Пирсе
*** Лямбда с символами (5.1, 5.3)
Дан тип

#+BEGIN_src haskell
data TermS = SymS Symbol        -- x
           | LamS Symbol TermS  -- \x -> t
           | AppS TermS TermS   -- t1 t2
           deriving (Eq,Show,Read)
#+END_src

Реализовать функции 

#+BEGIN_src haskell
alpha :: TermS -> TermS
alpha = error "Implement me!"

beta :: TermS -> Maybe TermS
beta = error "Implement me!"
#+END_src

Функция alpha должна выполнять альфа-преобразование: переименовать все переменные так, чтобы все они были разными.
Например, так
#+BEGIN_src haskell
-- \x -> \x -> \x -> (\b -> \f -> \s -> b f s) (\x -> \y -> x) (\x -> x) (\x -> \y -> y)
-- ~>
-- \a -> \b -> \c -> (\d -> \e -> \f -> d e f) (\g -> \h -> g) (\i -> i) (\j -> \k -> k)

-- let
sym x = SymS (Symbol x)
lam x t = LamS (Symbol x) t
app t1 t1 = AppS t1 t2
-- then (possible variant of alpha)
alpha (lam "x" $ app (lam "x" $ sym "x") (sym "x")) 
  == lam "a" (app (lam "b" $ sym "b") (sym "a"))
#+END_src

Функция beta должна выполнять один шаг редукции, если это возможно. Стратегия вычислений - полная, т.е. редуцируются все возможные редексы:
#+BEGIN_src haskell
-- \a -> \b -> \c -> (\d -> \e -> \f -> d e f) (\g -> \h -> g) (\i -> i) (\j -> \k -> k)
-- \a -> \b -> \c -> (\e -> \f -> (\g -> \h -> g) e f) (\i -> i) (\j -> \k -> k)
-- \a -> \b -> \c -> (\f -> (\g -> \h -> g) (\i -> i) f) (\j -> \k -> k)
-- \a -> \b -> \c -> (\g -> \h -> g) (\i -> i) (\j -> \k -> k) 
-- \a -> \b -> \c -> (\h -> (\i -> i)) (\j -> \k -> k) 
-- \a -> \b -> \c -> (\i -> i) 
-- \a -> a
-- =/>

-- let
sym x = SymS (Symbol x)
lam x t = LamS (Symbol x) t
app t1 t1 = AppS t1 t2
-- then
beta (lam "x" $ app (app (lam "t" $ lam "f" $ sym "t") (sym "x")) (lam "z" $ sym "z")) 
  == Just $ lam "x" $ app (lam "f" $ sym "x") (lam "z" $ sym "z")
-- and
beta (lam "x" $ sym "x") == Nothing
#+END_src haskell

*** Лямбда с индексами де Брауна (6)
Терм задаётся следующим образом.
#+BEGIN_src haskell
data TermI = SymI Int
           | LamI TermI
           | AppI TermI TermI
           deriving (Eq,Show,Read)
#+END_src

Следует написать функцию перевода из лямбда-исчисления с символами в лямбда-исчисление с индексами де Брауна
#+BEGIN_src haskell
toTermI :: TermS -> TermI
toTermI = error "Implement me!"

-- let
sym x = SymS (Symbol x)
lam x t = LamS (Symbol x) t
app t1 t1 = AppS t1 t2
-- then
toTermI (lam "x" $ app (lam "x" $ sym "x") (lam "x" $ lam "y" $ app (sym "y") (lam "y" $ sym "x")))
  == LamI (AppI (LamI (SymI 0)) (LamI (LamI (AppI (SymI 0) (LamI (SymI 2))))))
--                ^---------^     ^     ^---------------^              ^
--                                \------------------------------------/
#+END_src

Функция выполнения одного шага.
#+BEGIN_src haskell
betaI :: TermI -> Maybe TermI
betaI = error "Implement me!"
#+END_src
** Дополнения (5.2)
В типе TermP необходимо оставить только конструкторы, относящиеся к заданному варианту.
Необходимо реализовать кодирование (Чёрча) в терминах лямбда-исчисления.

 * Булевские константы: константы, операции "и", "или", "не".
 * Натуральные числа: константы, операции сложения и умножения. Операции вычитания и деления являются опциональными и дают +10%.
 * Рекурсия + взаимная рекурсия. Опционально, +50% и +50%.
 * Пары. Конструктор пары, операции получения первого и второго аргумента.
 * Списки. Конструктор списка, операции проверки на пустоту, получения головы и хвоста.
** Языки программирования
Можно выбрать любой язык, +если он Haskell+ но на вход программе будет подаваться терм в том виде, в котором его выводит стандартный инстанс Show TermP.

На вход программе подаётся одна строка, содержащая корректный терм типа TermP (в соответствии с дополнениями)

На выход программа должна вывести (в том виде, в котором выводит стандартный Show) значение типа Either (Maybe TermI) (Maybe TermP) в зависимости от варианта.
** Оценка
Вычисляется минимальная глубина ~d~ терма, при котором программа работает неверно. Вычисляется сумма всех процентов ~p~ за корректно реализованные опциональные дополнения.

Оценка вычисляется по следующей формуле:
#+BEGIN_src haskell
value :: Double -> Maybe Int -> Int
value p = floor . (/100) . (*p) . maybe 25 (\d -> 20 * (1 - 1 / phi ^ d))
#+END_src
Иными словами, чем больше глубина терма, на которой программа падает, тем ближе оценка к 20; если программа работает корректно - дополнительные 5 баллов.
** Сроки
Срок сдачи: 2-3 ноября 2017 г.
* Номер варианта
Номера вариантов и дополнений выбираются следующим образом:
 - номер в списке (например, 19) переводится в двоичную систему (10011)
 - важны только последние три бита (011)
 - наименее значимый бит определяет вариант, 0 - лямбда с индексами, 1 - лямбда с символами (здесь 1: с символами)
 - второй бит: 0 - натуральные числа, 1 - булевские константы (здесь 1: булевские)
 - третий бит: 0 - списки, 1 - пары

*** Список группы
1	Алишев Наиль Анварович
2	Захаров Лев Юрьевич
3	Плискин Александр Маркович
4	Хаков Рустам Айратович
5	Шайфутдинов Айдар Ильдарович
6	Гарифьянов Рустем Ильдарович
7	Ерофеев Кирилл Юрьевич
8	Есьмуков Константин Олегович
9	Сафин Рамиль Набиуллович
10	Бадыгин Яков Васильевич
11	Мингазов Айдар Анварович
12	Минкаев Дамир Бакирович
13	Ионов Никита Сергеевич
14	Муллин Айнур Алмазович
15	Юсипов Иван Олегович
16	Агафонов Данил Олегович
17	Еникеев Артур Рустемович
18	Кузин Дмитрий Андреевич
19	Мальцев Олег Андреевич
20	Ситдиков Рузаль Раилевич
21	Чирков Илья Андруувич
22	Акимов Александр Анатольевич
23	Горлачев Олег Сергеевич
24	Егоров Максим Анатольевич
25	Исхаков Ильяс Ильшатович
26	Марушкай Никита Станиславович
27	Васина Алия Раилевна
28	Мусин Булат Николаевич
29	Терзиян Анастасия Сергеевна
30	Тучков Алексей Николаевич
31  Матросов Кирилл Евгеньевич